// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TRPMCATALOG_TITAN_RESOURCE_H_
#define FLATBUFFERS_GENERATED_TRPMCATALOG_TITAN_RESOURCE_H_

#include "flatbuffers/flatbuffers.h"

namespace Titan {
namespace Resource {

struct VersionInfo;
struct VersionInfoBuilder;
struct VersionInfoT;

struct SpeciesInfo;
struct SpeciesInfoBuilder;
struct SpeciesInfoT;

struct AnimationInfo;
struct AnimationInfoBuilder;
struct AnimationInfoT;

struct LocatorInfo;
struct LocatorInfoBuilder;
struct LocatorInfoT;

struct CatalogEntry;
struct CatalogEntryBuilder;
struct CatalogEntryT;

struct Catalog;
struct CatalogBuilder;
struct CatalogT;

struct VersionInfoT : public ::flatbuffers::NativeTable {
  typedef VersionInfo TableType;
  uint32_t version = 0;
};

struct VersionInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VersionInfoT NativeTableType;
  typedef VersionInfoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4
  };
  uint32_t version() const {
    return GetField<uint32_t>(VT_VERSION, 0);
  }
  bool mutate_version(uint32_t _version = 0) {
    return SetField<uint32_t>(VT_VERSION, _version, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_VERSION, 4) &&
           verifier.EndTable();
  }
  VersionInfoT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(VersionInfoT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<VersionInfo> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const VersionInfoT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct VersionInfoBuilder {
  typedef VersionInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_version(uint32_t version) {
    fbb_.AddElement<uint32_t>(VersionInfo::VT_VERSION, version, 0);
  }
  explicit VersionInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VersionInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VersionInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<VersionInfo> CreateVersionInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t version = 0) {
  VersionInfoBuilder builder_(_fbb);
  builder_.add_version(version);
  return builder_.Finish();
}

struct VersionInfo::Traits {
  using type = VersionInfo;
  static auto constexpr Create = CreateVersionInfo;
};

::flatbuffers::Offset<VersionInfo> CreateVersionInfo(::flatbuffers::FlatBufferBuilder &_fbb, const VersionInfoT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SpeciesInfoT : public ::flatbuffers::NativeTable {
  typedef SpeciesInfo TableType;
  uint16_t species = 0;
  uint16_t form = 0;
  uint8_t gender = 0;
};

struct SpeciesInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SpeciesInfoT NativeTableType;
  typedef SpeciesInfoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SPECIES = 4,
    VT_FORM = 6,
    VT_GENDER = 8
  };
  uint16_t species() const {
    return GetField<uint16_t>(VT_SPECIES, 0);
  }
  bool mutate_species(uint16_t _species = 0) {
    return SetField<uint16_t>(VT_SPECIES, _species, 0);
  }
  uint16_t form() const {
    return GetField<uint16_t>(VT_FORM, 0);
  }
  bool mutate_form(uint16_t _form = 0) {
    return SetField<uint16_t>(VT_FORM, _form, 0);
  }
  uint8_t gender() const {
    return GetField<uint8_t>(VT_GENDER, 0);
  }
  bool mutate_gender(uint8_t _gender = 0) {
    return SetField<uint8_t>(VT_GENDER, _gender, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_SPECIES, 2) &&
           VerifyField<uint16_t>(verifier, VT_FORM, 2) &&
           VerifyField<uint8_t>(verifier, VT_GENDER, 1) &&
           verifier.EndTable();
  }
  SpeciesInfoT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SpeciesInfoT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<SpeciesInfo> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SpeciesInfoT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SpeciesInfoBuilder {
  typedef SpeciesInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_species(uint16_t species) {
    fbb_.AddElement<uint16_t>(SpeciesInfo::VT_SPECIES, species, 0);
  }
  void add_form(uint16_t form) {
    fbb_.AddElement<uint16_t>(SpeciesInfo::VT_FORM, form, 0);
  }
  void add_gender(uint8_t gender) {
    fbb_.AddElement<uint8_t>(SpeciesInfo::VT_GENDER, gender, 0);
  }
  explicit SpeciesInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SpeciesInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SpeciesInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SpeciesInfo> CreateSpeciesInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint16_t species = 0,
    uint16_t form = 0,
    uint8_t gender = 0) {
  SpeciesInfoBuilder builder_(_fbb);
  builder_.add_form(form);
  builder_.add_species(species);
  builder_.add_gender(gender);
  return builder_.Finish();
}

struct SpeciesInfo::Traits {
  using type = SpeciesInfo;
  static auto constexpr Create = CreateSpeciesInfo;
};

::flatbuffers::Offset<SpeciesInfo> CreateSpeciesInfo(::flatbuffers::FlatBufferBuilder &_fbb, const SpeciesInfoT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AnimationInfoT : public ::flatbuffers::NativeTable {
  typedef AnimationInfo TableType;
  int16_t form_number = 0;
  std::string path{};
};

struct AnimationInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AnimationInfoT NativeTableType;
  typedef AnimationInfoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORM_NUMBER = 4,
    VT_PATH = 6
  };
  int16_t form_number() const {
    return GetField<int16_t>(VT_FORM_NUMBER, 0);
  }
  bool mutate_form_number(int16_t _form_number = 0) {
    return SetField<int16_t>(VT_FORM_NUMBER, _form_number, 0);
  }
  const ::flatbuffers::String *path() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PATH);
  }
  ::flatbuffers::String *mutable_path() {
    return GetPointer<::flatbuffers::String *>(VT_PATH);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_FORM_NUMBER, 2) &&
           VerifyOffset(verifier, VT_PATH) &&
           verifier.VerifyString(path()) &&
           verifier.EndTable();
  }
  AnimationInfoT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AnimationInfoT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<AnimationInfo> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AnimationInfoT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AnimationInfoBuilder {
  typedef AnimationInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_form_number(int16_t form_number) {
    fbb_.AddElement<int16_t>(AnimationInfo::VT_FORM_NUMBER, form_number, 0);
  }
  void add_path(::flatbuffers::Offset<::flatbuffers::String> path) {
    fbb_.AddOffset(AnimationInfo::VT_PATH, path);
  }
  explicit AnimationInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AnimationInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AnimationInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AnimationInfo> CreateAnimationInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int16_t form_number = 0,
    ::flatbuffers::Offset<::flatbuffers::String> path = 0) {
  AnimationInfoBuilder builder_(_fbb);
  builder_.add_path(path);
  builder_.add_form_number(form_number);
  return builder_.Finish();
}

struct AnimationInfo::Traits {
  using type = AnimationInfo;
  static auto constexpr Create = CreateAnimationInfo;
};

inline ::flatbuffers::Offset<AnimationInfo> CreateAnimationInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int16_t form_number = 0,
    const char *path = nullptr) {
  auto path__ = path ? _fbb.CreateString(path) : 0;
  return Titan::Resource::CreateAnimationInfo(
      _fbb,
      form_number,
      path__);
}

::flatbuffers::Offset<AnimationInfo> CreateAnimationInfo(::flatbuffers::FlatBufferBuilder &_fbb, const AnimationInfoT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LocatorInfoT : public ::flatbuffers::NativeTable {
  typedef LocatorInfo TableType;
  int16_t form_number = 0;
  uint8_t loc_index = 0;
  std::string loc_path{};
};

struct LocatorInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LocatorInfoT NativeTableType;
  typedef LocatorInfoBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORM_NUMBER = 4,
    VT_LOC_INDEX = 6,
    VT_LOC_PATH = 8
  };
  int16_t form_number() const {
    return GetField<int16_t>(VT_FORM_NUMBER, 0);
  }
  bool mutate_form_number(int16_t _form_number = 0) {
    return SetField<int16_t>(VT_FORM_NUMBER, _form_number, 0);
  }
  uint8_t loc_index() const {
    return GetField<uint8_t>(VT_LOC_INDEX, 0);
  }
  bool mutate_loc_index(uint8_t _loc_index = 0) {
    return SetField<uint8_t>(VT_LOC_INDEX, _loc_index, 0);
  }
  const ::flatbuffers::String *loc_path() const {
    return GetPointer<const ::flatbuffers::String *>(VT_LOC_PATH);
  }
  ::flatbuffers::String *mutable_loc_path() {
    return GetPointer<::flatbuffers::String *>(VT_LOC_PATH);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int16_t>(verifier, VT_FORM_NUMBER, 2) &&
           VerifyField<uint8_t>(verifier, VT_LOC_INDEX, 1) &&
           VerifyOffset(verifier, VT_LOC_PATH) &&
           verifier.VerifyString(loc_path()) &&
           verifier.EndTable();
  }
  LocatorInfoT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LocatorInfoT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<LocatorInfo> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LocatorInfoT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LocatorInfoBuilder {
  typedef LocatorInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_form_number(int16_t form_number) {
    fbb_.AddElement<int16_t>(LocatorInfo::VT_FORM_NUMBER, form_number, 0);
  }
  void add_loc_index(uint8_t loc_index) {
    fbb_.AddElement<uint8_t>(LocatorInfo::VT_LOC_INDEX, loc_index, 0);
  }
  void add_loc_path(::flatbuffers::Offset<::flatbuffers::String> loc_path) {
    fbb_.AddOffset(LocatorInfo::VT_LOC_PATH, loc_path);
  }
  explicit LocatorInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LocatorInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LocatorInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<LocatorInfo> CreateLocatorInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int16_t form_number = 0,
    uint8_t loc_index = 0,
    ::flatbuffers::Offset<::flatbuffers::String> loc_path = 0) {
  LocatorInfoBuilder builder_(_fbb);
  builder_.add_loc_path(loc_path);
  builder_.add_form_number(form_number);
  builder_.add_loc_index(loc_index);
  return builder_.Finish();
}

struct LocatorInfo::Traits {
  using type = LocatorInfo;
  static auto constexpr Create = CreateLocatorInfo;
};

inline ::flatbuffers::Offset<LocatorInfo> CreateLocatorInfoDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    int16_t form_number = 0,
    uint8_t loc_index = 0,
    const char *loc_path = nullptr) {
  auto loc_path__ = loc_path ? _fbb.CreateString(loc_path) : 0;
  return Titan::Resource::CreateLocatorInfo(
      _fbb,
      form_number,
      loc_index,
      loc_path__);
}

::flatbuffers::Offset<LocatorInfo> CreateLocatorInfo(::flatbuffers::FlatBufferBuilder &_fbb, const LocatorInfoT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CatalogEntryT : public ::flatbuffers::NativeTable {
  typedef CatalogEntry TableType;
  std::shared_ptr<Titan::Resource::SpeciesInfoT> species_info{};
  std::string model_path{};
  std::string material_table_path{};
  std::string config_path{};
  std::vector<std::shared_ptr<Titan::Resource::AnimationInfoT>> animations{};
  std::vector<std::shared_ptr<Titan::Resource::LocatorInfoT>> locators{};
  std::string icon_path{};
  uint32_t unk_id = 0;
  CatalogEntryT() = default;
  CatalogEntryT(const CatalogEntryT &o);
  CatalogEntryT(CatalogEntryT&&) FLATBUFFERS_NOEXCEPT = default;
  CatalogEntryT &operator=(CatalogEntryT o) FLATBUFFERS_NOEXCEPT;
};

struct CatalogEntry FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CatalogEntryT NativeTableType;
  typedef CatalogEntryBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SPECIES_INFO = 4,
    VT_MODEL_PATH = 6,
    VT_MATERIAL_TABLE_PATH = 8,
    VT_CONFIG_PATH = 10,
    VT_ANIMATIONS = 12,
    VT_LOCATORS = 14,
    VT_ICON_PATH = 16,
    VT_UNK_ID = 18
  };
  const Titan::Resource::SpeciesInfo *species_info() const {
    return GetPointer<const Titan::Resource::SpeciesInfo *>(VT_SPECIES_INFO);
  }
  Titan::Resource::SpeciesInfo *mutable_species_info() {
    return GetPointer<Titan::Resource::SpeciesInfo *>(VT_SPECIES_INFO);
  }
  const ::flatbuffers::String *model_path() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MODEL_PATH);
  }
  ::flatbuffers::String *mutable_model_path() {
    return GetPointer<::flatbuffers::String *>(VT_MODEL_PATH);
  }
  const ::flatbuffers::String *material_table_path() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MATERIAL_TABLE_PATH);
  }
  ::flatbuffers::String *mutable_material_table_path() {
    return GetPointer<::flatbuffers::String *>(VT_MATERIAL_TABLE_PATH);
  }
  const ::flatbuffers::String *config_path() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONFIG_PATH);
  }
  ::flatbuffers::String *mutable_config_path() {
    return GetPointer<::flatbuffers::String *>(VT_CONFIG_PATH);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Resource::AnimationInfo>> *animations() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Resource::AnimationInfo>> *>(VT_ANIMATIONS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Resource::AnimationInfo>> *mutable_animations() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Resource::AnimationInfo>> *>(VT_ANIMATIONS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Resource::LocatorInfo>> *locators() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Resource::LocatorInfo>> *>(VT_LOCATORS);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Resource::LocatorInfo>> *mutable_locators() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Resource::LocatorInfo>> *>(VT_LOCATORS);
  }
  const ::flatbuffers::String *icon_path() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ICON_PATH);
  }
  ::flatbuffers::String *mutable_icon_path() {
    return GetPointer<::flatbuffers::String *>(VT_ICON_PATH);
  }
  uint32_t unk_id() const {
    return GetField<uint32_t>(VT_UNK_ID, 0);
  }
  bool mutate_unk_id(uint32_t _unk_id = 0) {
    return SetField<uint32_t>(VT_UNK_ID, _unk_id, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SPECIES_INFO) &&
           verifier.VerifyTable(species_info()) &&
           VerifyOffset(verifier, VT_MODEL_PATH) &&
           verifier.VerifyString(model_path()) &&
           VerifyOffset(verifier, VT_MATERIAL_TABLE_PATH) &&
           verifier.VerifyString(material_table_path()) &&
           VerifyOffset(verifier, VT_CONFIG_PATH) &&
           verifier.VerifyString(config_path()) &&
           VerifyOffset(verifier, VT_ANIMATIONS) &&
           verifier.VerifyVector(animations()) &&
           verifier.VerifyVectorOfTables(animations()) &&
           VerifyOffset(verifier, VT_LOCATORS) &&
           verifier.VerifyVector(locators()) &&
           verifier.VerifyVectorOfTables(locators()) &&
           VerifyOffset(verifier, VT_ICON_PATH) &&
           verifier.VerifyString(icon_path()) &&
           VerifyField<uint32_t>(verifier, VT_UNK_ID, 4) &&
           verifier.EndTable();
  }
  CatalogEntryT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CatalogEntryT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<CatalogEntry> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CatalogEntryT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CatalogEntryBuilder {
  typedef CatalogEntry Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_species_info(::flatbuffers::Offset<Titan::Resource::SpeciesInfo> species_info) {
    fbb_.AddOffset(CatalogEntry::VT_SPECIES_INFO, species_info);
  }
  void add_model_path(::flatbuffers::Offset<::flatbuffers::String> model_path) {
    fbb_.AddOffset(CatalogEntry::VT_MODEL_PATH, model_path);
  }
  void add_material_table_path(::flatbuffers::Offset<::flatbuffers::String> material_table_path) {
    fbb_.AddOffset(CatalogEntry::VT_MATERIAL_TABLE_PATH, material_table_path);
  }
  void add_config_path(::flatbuffers::Offset<::flatbuffers::String> config_path) {
    fbb_.AddOffset(CatalogEntry::VT_CONFIG_PATH, config_path);
  }
  void add_animations(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Resource::AnimationInfo>>> animations) {
    fbb_.AddOffset(CatalogEntry::VT_ANIMATIONS, animations);
  }
  void add_locators(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Resource::LocatorInfo>>> locators) {
    fbb_.AddOffset(CatalogEntry::VT_LOCATORS, locators);
  }
  void add_icon_path(::flatbuffers::Offset<::flatbuffers::String> icon_path) {
    fbb_.AddOffset(CatalogEntry::VT_ICON_PATH, icon_path);
  }
  void add_unk_id(uint32_t unk_id) {
    fbb_.AddElement<uint32_t>(CatalogEntry::VT_UNK_ID, unk_id, 0);
  }
  explicit CatalogEntryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CatalogEntry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CatalogEntry>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<CatalogEntry> CreateCatalogEntry(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Titan::Resource::SpeciesInfo> species_info = 0,
    ::flatbuffers::Offset<::flatbuffers::String> model_path = 0,
    ::flatbuffers::Offset<::flatbuffers::String> material_table_path = 0,
    ::flatbuffers::Offset<::flatbuffers::String> config_path = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Resource::AnimationInfo>>> animations = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Resource::LocatorInfo>>> locators = 0,
    ::flatbuffers::Offset<::flatbuffers::String> icon_path = 0,
    uint32_t unk_id = 0) {
  CatalogEntryBuilder builder_(_fbb);
  builder_.add_unk_id(unk_id);
  builder_.add_icon_path(icon_path);
  builder_.add_locators(locators);
  builder_.add_animations(animations);
  builder_.add_config_path(config_path);
  builder_.add_material_table_path(material_table_path);
  builder_.add_model_path(model_path);
  builder_.add_species_info(species_info);
  return builder_.Finish();
}

struct CatalogEntry::Traits {
  using type = CatalogEntry;
  static auto constexpr Create = CreateCatalogEntry;
};

inline ::flatbuffers::Offset<CatalogEntry> CreateCatalogEntryDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Titan::Resource::SpeciesInfo> species_info = 0,
    const char *model_path = nullptr,
    const char *material_table_path = nullptr,
    const char *config_path = nullptr,
    const std::vector<::flatbuffers::Offset<Titan::Resource::AnimationInfo>> *animations = nullptr,
    const std::vector<::flatbuffers::Offset<Titan::Resource::LocatorInfo>> *locators = nullptr,
    const char *icon_path = nullptr,
    uint32_t unk_id = 0) {
  auto model_path__ = model_path ? _fbb.CreateString(model_path) : 0;
  auto material_table_path__ = material_table_path ? _fbb.CreateString(material_table_path) : 0;
  auto config_path__ = config_path ? _fbb.CreateString(config_path) : 0;
  auto animations__ = animations ? _fbb.CreateVector<::flatbuffers::Offset<Titan::Resource::AnimationInfo>>(*animations) : 0;
  auto locators__ = locators ? _fbb.CreateVector<::flatbuffers::Offset<Titan::Resource::LocatorInfo>>(*locators) : 0;
  auto icon_path__ = icon_path ? _fbb.CreateString(icon_path) : 0;
  return Titan::Resource::CreateCatalogEntry(
      _fbb,
      species_info,
      model_path__,
      material_table_path__,
      config_path__,
      animations__,
      locators__,
      icon_path__,
      unk_id);
}

::flatbuffers::Offset<CatalogEntry> CreateCatalogEntry(::flatbuffers::FlatBufferBuilder &_fbb, const CatalogEntryT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CatalogT : public ::flatbuffers::NativeTable {
  typedef Catalog TableType;
  std::shared_ptr<Titan::Resource::VersionInfoT> version{};
  std::vector<std::shared_ptr<Titan::Resource::CatalogEntryT>> table{};
  CatalogT() = default;
  CatalogT(const CatalogT &o);
  CatalogT(CatalogT&&) FLATBUFFERS_NOEXCEPT = default;
  CatalogT &operator=(CatalogT o) FLATBUFFERS_NOEXCEPT;
};

struct Catalog FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CatalogT NativeTableType;
  typedef CatalogBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_TABLE = 6
  };
  const Titan::Resource::VersionInfo *version() const {
    return GetPointer<const Titan::Resource::VersionInfo *>(VT_VERSION);
  }
  Titan::Resource::VersionInfo *mutable_version() {
    return GetPointer<Titan::Resource::VersionInfo *>(VT_VERSION);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Resource::CatalogEntry>> *table() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Resource::CatalogEntry>> *>(VT_TABLE);
  }
  ::flatbuffers::Vector<::flatbuffers::Offset<Titan::Resource::CatalogEntry>> *mutable_table() {
    return GetPointer<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Resource::CatalogEntry>> *>(VT_TABLE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.VerifyTable(version()) &&
           VerifyOffset(verifier, VT_TABLE) &&
           verifier.VerifyVector(table()) &&
           verifier.VerifyVectorOfTables(table()) &&
           verifier.EndTable();
  }
  CatalogT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CatalogT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<Catalog> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CatalogT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CatalogBuilder {
  typedef Catalog Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_version(::flatbuffers::Offset<Titan::Resource::VersionInfo> version) {
    fbb_.AddOffset(Catalog::VT_VERSION, version);
  }
  void add_table(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Resource::CatalogEntry>>> table) {
    fbb_.AddOffset(Catalog::VT_TABLE, table);
  }
  explicit CatalogBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Catalog> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Catalog>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Catalog> CreateCatalog(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Titan::Resource::VersionInfo> version = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<Titan::Resource::CatalogEntry>>> table = 0) {
  CatalogBuilder builder_(_fbb);
  builder_.add_table(table);
  builder_.add_version(version);
  return builder_.Finish();
}

struct Catalog::Traits {
  using type = Catalog;
  static auto constexpr Create = CreateCatalog;
};

inline ::flatbuffers::Offset<Catalog> CreateCatalogDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<Titan::Resource::VersionInfo> version = 0,
    const std::vector<::flatbuffers::Offset<Titan::Resource::CatalogEntry>> *table = nullptr) {
  auto table__ = table ? _fbb.CreateVector<::flatbuffers::Offset<Titan::Resource::CatalogEntry>>(*table) : 0;
  return Titan::Resource::CreateCatalog(
      _fbb,
      version,
      table__);
}

::flatbuffers::Offset<Catalog> CreateCatalog(::flatbuffers::FlatBufferBuilder &_fbb, const CatalogT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline VersionInfoT *VersionInfo::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<VersionInfoT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void VersionInfo::UnPackTo(VersionInfoT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = version(); _o->version = _e; }
}

inline ::flatbuffers::Offset<VersionInfo> VersionInfo::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const VersionInfoT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateVersionInfo(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<VersionInfo> CreateVersionInfo(::flatbuffers::FlatBufferBuilder &_fbb, const VersionInfoT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const VersionInfoT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _version = _o->version;
  return Titan::Resource::CreateVersionInfo(
      _fbb,
      _version);
}

inline SpeciesInfoT *SpeciesInfo::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<SpeciesInfoT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SpeciesInfo::UnPackTo(SpeciesInfoT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = species(); _o->species = _e; }
  { auto _e = form(); _o->form = _e; }
  { auto _e = gender(); _o->gender = _e; }
}

inline ::flatbuffers::Offset<SpeciesInfo> SpeciesInfo::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const SpeciesInfoT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSpeciesInfo(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<SpeciesInfo> CreateSpeciesInfo(::flatbuffers::FlatBufferBuilder &_fbb, const SpeciesInfoT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const SpeciesInfoT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _species = _o->species;
  auto _form = _o->form;
  auto _gender = _o->gender;
  return Titan::Resource::CreateSpeciesInfo(
      _fbb,
      _species,
      _form,
      _gender);
}

inline AnimationInfoT *AnimationInfo::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<AnimationInfoT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AnimationInfo::UnPackTo(AnimationInfoT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = form_number(); _o->form_number = _e; }
  { auto _e = path(); if (_e) _o->path = _e->str(); }
}

inline ::flatbuffers::Offset<AnimationInfo> AnimationInfo::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AnimationInfoT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAnimationInfo(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<AnimationInfo> CreateAnimationInfo(::flatbuffers::FlatBufferBuilder &_fbb, const AnimationInfoT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const AnimationInfoT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _form_number = _o->form_number;
  auto _path = _o->path.empty() ? 0 : _fbb.CreateString(_o->path);
  return Titan::Resource::CreateAnimationInfo(
      _fbb,
      _form_number,
      _path);
}

inline LocatorInfoT *LocatorInfo::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<LocatorInfoT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LocatorInfo::UnPackTo(LocatorInfoT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = form_number(); _o->form_number = _e; }
  { auto _e = loc_index(); _o->loc_index = _e; }
  { auto _e = loc_path(); if (_e) _o->loc_path = _e->str(); }
}

inline ::flatbuffers::Offset<LocatorInfo> LocatorInfo::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const LocatorInfoT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLocatorInfo(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<LocatorInfo> CreateLocatorInfo(::flatbuffers::FlatBufferBuilder &_fbb, const LocatorInfoT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const LocatorInfoT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _form_number = _o->form_number;
  auto _loc_index = _o->loc_index;
  auto _loc_path = _o->loc_path.empty() ? 0 : _fbb.CreateString(_o->loc_path);
  return Titan::Resource::CreateLocatorInfo(
      _fbb,
      _form_number,
      _loc_index,
      _loc_path);
}

inline CatalogEntryT::CatalogEntryT(const CatalogEntryT &o)
      : species_info((o.species_info) ? new Titan::Resource::SpeciesInfoT(*o.species_info) : nullptr),
        model_path(o.model_path),
        material_table_path(o.material_table_path),
        config_path(o.config_path),
        icon_path(o.icon_path),
        unk_id(o.unk_id) {
  animations.reserve(o.animations.size());
  for (const auto &animations_ : o.animations) { animations.emplace_back((animations_) ? new Titan::Resource::AnimationInfoT(*animations_) : nullptr); }
  locators.reserve(o.locators.size());
  for (const auto &locators_ : o.locators) { locators.emplace_back((locators_) ? new Titan::Resource::LocatorInfoT(*locators_) : nullptr); }
}

inline CatalogEntryT &CatalogEntryT::operator=(CatalogEntryT o) FLATBUFFERS_NOEXCEPT {
  std::swap(species_info, o.species_info);
  std::swap(model_path, o.model_path);
  std::swap(material_table_path, o.material_table_path);
  std::swap(config_path, o.config_path);
  std::swap(animations, o.animations);
  std::swap(locators, o.locators);
  std::swap(icon_path, o.icon_path);
  std::swap(unk_id, o.unk_id);
  return *this;
}

inline CatalogEntryT *CatalogEntry::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<CatalogEntryT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CatalogEntry::UnPackTo(CatalogEntryT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = species_info(); if (_e) { if(_o->species_info) { _e->UnPackTo(_o->species_info.get(), _resolver); } else { _o->species_info = std::shared_ptr<Titan::Resource::SpeciesInfoT>(_e->UnPack(_resolver)); } } else if (_o->species_info) { _o->species_info.reset(); } }
  { auto _e = model_path(); if (_e) _o->model_path = _e->str(); }
  { auto _e = material_table_path(); if (_e) _o->material_table_path = _e->str(); }
  { auto _e = config_path(); if (_e) _o->config_path = _e->str(); }
  { auto _e = animations(); if (_e) { _o->animations.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->animations[_i]) { _e->Get(_i)->UnPackTo(_o->animations[_i].get(), _resolver); } else { _o->animations[_i] = std::shared_ptr<Titan::Resource::AnimationInfoT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->animations.resize(0); } }
  { auto _e = locators(); if (_e) { _o->locators.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->locators[_i]) { _e->Get(_i)->UnPackTo(_o->locators[_i].get(), _resolver); } else { _o->locators[_i] = std::shared_ptr<Titan::Resource::LocatorInfoT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->locators.resize(0); } }
  { auto _e = icon_path(); if (_e) _o->icon_path = _e->str(); }
  { auto _e = unk_id(); _o->unk_id = _e; }
}

inline ::flatbuffers::Offset<CatalogEntry> CatalogEntry::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CatalogEntryT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCatalogEntry(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<CatalogEntry> CreateCatalogEntry(::flatbuffers::FlatBufferBuilder &_fbb, const CatalogEntryT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CatalogEntryT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _species_info = _o->species_info ? CreateSpeciesInfo(_fbb, _o->species_info.get(), _rehasher) : 0;
  auto _model_path = _o->model_path.empty() ? 0 : _fbb.CreateString(_o->model_path);
  auto _material_table_path = _o->material_table_path.empty() ? 0 : _fbb.CreateString(_o->material_table_path);
  auto _config_path = _o->config_path.empty() ? 0 : _fbb.CreateString(_o->config_path);
  auto _animations = _o->animations.size() ? _fbb.CreateVector<::flatbuffers::Offset<Titan::Resource::AnimationInfo>> (_o->animations.size(), [](size_t i, _VectorArgs *__va) { return CreateAnimationInfo(*__va->__fbb, __va->__o->animations[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _locators = _o->locators.size() ? _fbb.CreateVector<::flatbuffers::Offset<Titan::Resource::LocatorInfo>> (_o->locators.size(), [](size_t i, _VectorArgs *__va) { return CreateLocatorInfo(*__va->__fbb, __va->__o->locators[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _icon_path = _o->icon_path.empty() ? 0 : _fbb.CreateString(_o->icon_path);
  auto _unk_id = _o->unk_id;
  return Titan::Resource::CreateCatalogEntry(
      _fbb,
      _species_info,
      _model_path,
      _material_table_path,
      _config_path,
      _animations,
      _locators,
      _icon_path,
      _unk_id);
}

inline CatalogT::CatalogT(const CatalogT &o)
      : version((o.version) ? new Titan::Resource::VersionInfoT(*o.version) : nullptr) {
  table.reserve(o.table.size());
  for (const auto &table_ : o.table) { table.emplace_back((table_) ? new Titan::Resource::CatalogEntryT(*table_) : nullptr); }
}

inline CatalogT &CatalogT::operator=(CatalogT o) FLATBUFFERS_NOEXCEPT {
  std::swap(version, o.version);
  std::swap(table, o.table);
  return *this;
}

inline CatalogT *Catalog::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<CatalogT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Catalog::UnPackTo(CatalogT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = version(); if (_e) { if(_o->version) { _e->UnPackTo(_o->version.get(), _resolver); } else { _o->version = std::shared_ptr<Titan::Resource::VersionInfoT>(_e->UnPack(_resolver)); } } else if (_o->version) { _o->version.reset(); } }
  { auto _e = table(); if (_e) { _o->table.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->table[_i]) { _e->Get(_i)->UnPackTo(_o->table[_i].get(), _resolver); } else { _o->table[_i] = std::shared_ptr<Titan::Resource::CatalogEntryT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->table.resize(0); } }
}

inline ::flatbuffers::Offset<Catalog> Catalog::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const CatalogT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCatalog(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<Catalog> CreateCatalog(::flatbuffers::FlatBufferBuilder &_fbb, const CatalogT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const CatalogT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _version = _o->version ? CreateVersionInfo(_fbb, _o->version.get(), _rehasher) : 0;
  auto _table = _o->table.size() ? _fbb.CreateVector<::flatbuffers::Offset<Titan::Resource::CatalogEntry>> (_o->table.size(), [](size_t i, _VectorArgs *__va) { return CreateCatalogEntry(*__va->__fbb, __va->__o->table[i].get(), __va->__rehasher); }, &_va ) : 0;
  return Titan::Resource::CreateCatalog(
      _fbb,
      _version,
      _table);
}

inline const Titan::Resource::Catalog *GetCatalog(const void *buf) {
  return ::flatbuffers::GetRoot<Titan::Resource::Catalog>(buf);
}

inline const Titan::Resource::Catalog *GetSizePrefixedCatalog(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Titan::Resource::Catalog>(buf);
}

inline Catalog *GetMutableCatalog(void *buf) {
  return ::flatbuffers::GetMutableRoot<Catalog>(buf);
}

inline Titan::Resource::Catalog *GetMutableSizePrefixedCatalog(void *buf) {
  return ::flatbuffers::GetMutableSizePrefixedRoot<Titan::Resource::Catalog>(buf);
}

inline bool VerifyCatalogBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Titan::Resource::Catalog>(nullptr);
}

inline bool VerifySizePrefixedCatalogBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Titan::Resource::Catalog>(nullptr);
}

inline const char *CatalogExtension() {
  return "trpmcatalog";
}

inline void FinishCatalogBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Titan::Resource::Catalog> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedCatalogBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Titan::Resource::Catalog> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::shared_ptr<Titan::Resource::CatalogT> UnPackCatalog(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::shared_ptr<Titan::Resource::CatalogT>(GetCatalog(buf)->UnPack(res));
}

inline std::shared_ptr<Titan::Resource::CatalogT> UnPackSizePrefixedCatalog(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::shared_ptr<Titan::Resource::CatalogT>(GetSizePrefixedCatalog(buf)->UnPack(res));
}

}  // namespace Resource
}  // namespace Titan

#endif  // FLATBUFFERS_GENERATED_TRPMCATALOG_TITAN_RESOURCE_H_
